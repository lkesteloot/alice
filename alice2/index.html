<html>
    <head>
        <title>Alice II</title>
        <link href="../stylesheet.css" rel="stylesheet" type="text/css">
    </head>
    <body>
        <IMG SRC="alice2_banner.gif" WIDTH="227" HEIGHT="63"><BR><BR>

        <BR>

        <p><hr><p>

        In 1995, we
	(<a href="http://www.plunk.org/~grantham/">Brad Grantham</a>,
	<a href="mailto:grantham@plunk.org">grantham@plunk.org</a>,
	and <a href="http://www.teamten.com/lawrence/">Lawrence Kesteloot</a>)
	were living in Sunnyvale, about forty-five minutes south of San
        Francisco, California.<p>

        The Alice II was the obvious next step after the Alice I.  We
        decided to work on it together as a fun educational project.
        The Alice I was a single-board computer with everything
        hardwired into it.  The Alice II was designed to be
        extensible, with a bus and plug-in cards.  For simplicity we
        kept the Z-80 as the CPU, but that's about the only
        resemblance to the Alice I.<P>

        We used a rack-mounted modem frame that we found at <A
            HREF="http://www.weirdstuff.com/">Weird Stuff</A>.  It came with its
        own power supply, but it didn't provide the voltages we
        needed, so Lawrence <A HREF="power_supply.html">made his
            own</A>, which didn't work.  We ended up using a PC power
        supply, which gave us the right voltages and enough power.
        The nice thing about ours, though, was the amp-meter, which
        told us when we had a short circuit in our system.<P>

        We used a simple <A HREF="system_bus.html">system bus</A>
        that basically exported all
        the important pins of the Z-80.  Two 25-wire ribbon cables
        were used for the bus, each with DB-25s attached at regular
        intervals to plug the boards into.  Everything was attached
        to the back of the frame so that our cards could slide in
        and connect to the plugs.<P>

        We then set ourselves on making the plug-in boards.  We
        decided to first prototype the boards on breadboards, using
        long 25-pin cables to attach to the bus.  We would then make
        the <A HREF="printed_circuits.html">printed-circuit (PC)
            boards</A>.  We later found
        that we spent more time manufacturing the PC boards than
        designing or prototyping them, and in retrospect we should
        have found another method, such as wire-wrapping.<P>

        The first board was the <A HREF="clock_board.html">clock
            board</A>.  It was responsible
        for toggling the clock pin of the bus.  There were several
        switches that allowed the user to set the clock
        board in one of three states: single-step, variable, and
        full-speed.  The "variable" mode used a knob to go from
        stopped to 1 KHz, and the full-speed mode went at 1 MHz.<P>

        The best advice to anyone designing either hardware or
        software is to spend time on debugging tools -- they are
        always worth their development effort.  So we next built the
        <A HREF="debug_board.html">debug board</A>, which displayed
        the state of the bus.  Six
        7-segment displays showed the address and data bytes, and
        ten LEDs showed various pins of interest.  We could not have
        built the next two boards without this one.<P>

        We were torn between building a memory board next or a CPU
        board.  It's a chicken-and-egg problem since they both need
        each other in order to be tested.  We finally built both on
        breadboards, then built the memory board, followed by the
        CPU board.<P>

        The <A HREF="memory_board.html">memory board</A> has 16K of
        EPROM and 48K of RAM (since the
        Z-80 can only access 64K).  There's a switch on the board to
        turn 16K of the RAM into memory-mapped I/O.  We used this
        later for the bit-mapped display.<P>

        The <A HREF="cpu_board.html">CPU board</A> has a Z-80 CPU,
        an 8259 interrupt controller,
        and some glue chips.  We made a big mistake when making this
        board.  We got overconfident with the success of our
        previous boards, and didn't bother to prototype the 8259
        part of the board.  We had never used this chip, and it took
        us over a year to figure out why it wasn't working and to patch
        the board.  We even ended up making the board twice because
        our first version was so badly botched.<P>

        We wanted some input and output, so next came the
        <A HREF="io_board.html">I/O board</A>.  The input of
        choice was a standard PC keyboard, and
        the output, for simplicity, was a 2-line LCD display.  We
        wanted serial I/O as well to download code from our PC
        (burning EPROMs was becoming tedious).  We used a PIC chip
        to interface to all three.  Using the PIC was a good idea in
        the end, but added a level of complication that we hadn't
        expected.  Our computer was essentially a multi-CPU machine!
        Ironically, the I/O co-processor ran at 20 times the speed
        of the main CPU.<P>

        Our final board was the <A HREF="video_board.html">video
            board</A> -- we wanted to display
        images on a monitor.  It took us a long time to decide on
        the design.  At one point it seemed easier to use yet
        another PIC chip that would take drawing requests from the
        CPU.  Finally we settled on a simpler memory-mapped I/O
        scheme, with the CPU writing to memory and a counter reading
        from it.  We used an EPROM to map out the horizontal and
        vertical sync signals.  Although the board worked very well
        on the breadboard, it stopped working altogether when made
        into a PC board.  After many months of frustrations with
        analog electronics, we finally added enough capacitors to
        make it work.<P>

        Not a lot of <A HREF="software.html">software</A> was
        written.  We wrote the basic ROM functions needed to write
        to the LCD display and read from the keyboard; the PIC code
        to interface with the peripherals and the CPU; and a simple
        C compiler.  We even started on a multi-tasking operating
        system (the PIC board interrupts the CPU 10 times a second).
        In the end we didn't write any more software because every
        time we turned the machine on we had to spend two hours
        finding out why it had stopped working (usually a bad solder
        connection).<P>

        The whole Alice II project took about 4 years, with large
        breaks throughout.  We're not sure how much we spent on it,
        but it's probably on the order of a thousand dollars.
        We did half of it in Brad's apartment in
        Sunnyvale and half in his <A HREF="garage.html">garage</A>
        in Mountain View on Wednesday nights.  We <A
            HREF="learned_a_lot.html">learned a lot</A> and had a great
        time, but are glad to go back to software, where weenies
        like us belong.<P>

	You may find other interesting Z80 projects at
	<A HREF="http://www.z80.info/">www.z80.info</A>.<P>
    </body>
</html>

